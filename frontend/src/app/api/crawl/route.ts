import { NextRequest, NextResponse } from "next/server";
import { exec } from "child_process";
import { promisify } from "util";
import path from "path";
import fs from "fs/promises";

const execAsync = promisify(exec);

export async function POST(request: NextRequest) {
	try {
		const body = await request.json();
		const { startUrl, maxDepth = 3, maxPages = 50, credentials } = body;

		if (!startUrl) {
			return NextResponse.json(
				{ error: "startUrl is required" },
				{ status: 400 },
			);
		}

		const backendPath = path.join(process.cwd(), "..", "backend");
		const outputPath = path.join(backendPath, "user-flow-output.json");

		try {
			await fs.unlink(outputPath);
			console.log("üóëÔ∏è  Deleted old output file");
		} catch (error) {
		}

		// Build command
		const command = `cd "${backendPath}" && npm start "${startUrl}" ${maxDepth} ${maxPages}`;

		console.log("üöÄ Executing command:", command);

		try {
			const { stdout, stderr } = await execAsync(command, {
				timeout: 180000, // 3 minute timeout
				maxBuffer: 10 * 1024 * 1024, // 10MB buffer
			});

			console.log("stdout:", stdout);
			if (stderr) console.error("stderr:", stderr);
		} catch (execError: any) {
			console.error("‚ùå Execution error:", execError);
			return NextResponse.json(
				{
					error: "Failed to execute crawler",
					details: execError.message,
					stdout: execError.stdout,
					stderr: execError.stderr,
				},
				{ status: 500 },
			);
		}

		// Wait a bit for file to be written
		await new Promise((resolve) => setTimeout(resolve, 1000));

		// Check if file exists
		try {
			await fs.access(outputPath);
			console.log("‚úÖ Output file exists");
		} catch (error) {
			console.error("‚ùå Output file does not exist");
			return NextResponse.json(
				{ error: "Output file was not generated by crawler" },
				{ status: 500 },
			);
		}

		// Read the output file
		let outputData: string;
		try {
			outputData = await fs.readFile(outputPath, "utf-8");
		} catch (readError: any) {
			console.error("‚ùå Error reading output file:", readError);
			return NextResponse.json(
				{ error: "Failed to read output file", details: readError.message },
				{ status: 500 },
			);
		}

		// Validate JSON
		if (!outputData || outputData.trim().length === 0) {
			console.error("‚ùå Output file is empty");
			return NextResponse.json(
				{ error: "Output file is empty" },
				{ status: 500 },
			);
		}

		// Parse JSON
		let result;
		try {
			result = JSON.parse(outputData);
		} catch (parseError: any) {
			console.error("‚ùå JSON parse error:", parseError);
			console.error(
				"   First 200 chars of file:",
				outputData.substring(0, 200),
			);
			return NextResponse.json(
				{
					error: "Invalid JSON in output file",
					details: parseError.message,
					preview: outputData.substring(0, 200),
				},
				{ status: 500 },
			);
		}

		return NextResponse.json(result);
	} catch (error: any) {
		console.error("‚ùå Unexpected error in crawl API:", error);
		return NextResponse.json(
			{ error: error.message || "Failed to crawl website", stack: error.stack },
			{ status: 500 },
		);
	}
}

export const maxDuration = 300; // 5 minutes for Vercel
export const dynamic = "force-dynamic";
